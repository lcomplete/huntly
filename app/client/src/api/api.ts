/* tslint:disable */
/* eslint-disable */
/**
 * huntly api doc
 * huntly api doc for code generation
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiResultOfBatchFilterResult
 */
export interface ApiResultOfBatchFilterResult {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfBatchFilterResult
     */
    'code'?: number;
    /**
     * 
     * @type {BatchFilterResult}
     * @memberof ApiResultOfBatchFilterResult
     */
    'data'?: BatchFilterResult;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfBatchFilterResult
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfBatchMoveResult
 */
export interface ApiResultOfBatchMoveResult {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfBatchMoveResult
     */
    'code'?: number;
    /**
     * 
     * @type {BatchMoveResult}
     * @memberof ApiResultOfBatchMoveResult
     */
    'data'?: BatchMoveResult;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfBatchMoveResult
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfLibraryExportInfo
 */
export interface ApiResultOfLibraryExportInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfLibraryExportInfo
     */
    'code'?: number;
    /**
     * 
     * @type {LibraryExportInfo}
     * @memberof ApiResultOfLibraryExportInfo
     */
    'data'?: LibraryExportInfo;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfLibraryExportInfo
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfListOfPageHighlightDto
 */
export interface ApiResultOfListOfPageHighlightDto {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfListOfPageHighlightDto
     */
    'code'?: number;
    /**
     * 
     * @type {Array<PageHighlightDto>}
     * @memberof ApiResultOfListOfPageHighlightDto
     */
    'data'?: Array<PageHighlightDto>;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfListOfPageHighlightDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfMapOflongAndListOfPageHighlightDto
 */
export interface ApiResultOfMapOflongAndListOfPageHighlightDto {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfMapOflongAndListOfPageHighlightDto
     */
    'code'?: number;
    /**
     * 
     * @type {{ [key: string]: Array<PageHighlightDto>; }}
     * @memberof ApiResultOfMapOflongAndListOfPageHighlightDto
     */
    'data'?: { [key: string]: Array<PageHighlightDto>; };
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfMapOflongAndListOfPageHighlightDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfPageHighlightDto
 */
export interface ApiResultOfPageHighlightDto {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfPageHighlightDto
     */
    'code'?: number;
    /**
     * 
     * @type {PageHighlightDto}
     * @memberof ApiResultOfPageHighlightDto
     */
    'data'?: PageHighlightDto;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfPageHighlightDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfPageOfHighlightListItem
 */
export interface ApiResultOfPageOfHighlightListItem {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfPageOfHighlightListItem
     */
    'code'?: number;
    /**
     * 
     * @type {PageOfHighlightListItem}
     * @memberof ApiResultOfPageOfHighlightListItem
     */
    'data'?: PageOfHighlightListItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfPageOfHighlightListItem
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfboolean
 */
export interface ApiResultOfboolean {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfboolean
     */
    'code'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultOfboolean
     */
    'data'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfboolean
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfint
 */
export interface ApiResultOfint {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfint
     */
    'code'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfint
     */
    'data'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfint
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOflong
 */
export interface ApiResultOflong {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOflong
     */
    'code'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiResultOflong
     */
    'data'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOflong
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiResultOfstring
 */
export interface ApiResultOfstring {
    /**
     * 
     * @type {number}
     * @memberof ApiResultOfstring
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfstring
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResultOfstring
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ArticleContent
 */
export interface ArticleContent {
    /**
     * 
     * @type {string}
     * @memberof ArticleContent
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof ArticleContent
     */
    'pageId'?: number;
}
/**
 * 
 * @export
 * @interface ArticleShortcut
 */
export interface ArticleShortcut {
    /**
     * 
     * @type {string}
     * @memberof ArticleShortcut
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleShortcut
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleShortcut
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArticleShortcut
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ArticleShortcut
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ArticleShortcut
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ArticleShortcut
     */
    'sortOrder'?: number;
    /**
     * 
     * @type {string}
     * @memberof ArticleShortcut
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface BatchFilterQuery
 */
export interface BatchFilterQuery {
    /**
     * 
     * @type {string}
     * @memberof BatchFilterQuery
     */
    'author'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchFilterQuery
     */
    'collectionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchFilterQuery
     */
    'contentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchFilterQuery
     */
    'endDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BatchFilterQuery
     */
    'filterUnsorted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchFilterQuery
     */
    'page'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchFilterQuery
     */
    'readLater'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BatchFilterQuery
     */
    'saveStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchFilterQuery
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchFilterQuery
     */
    'starred'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BatchFilterQuery
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface BatchFilterResult
 */
export interface BatchFilterResult {
    /**
     * 
     * @type {number}
     * @memberof BatchFilterResult
     */
    'currentPage'?: number;
    /**
     * 
     * @type {Array<BatchPageItem>}
     * @memberof BatchFilterResult
     */
    'items'?: Array<BatchPageItem>;
    /**
     * 
     * @type {number}
     * @memberof BatchFilterResult
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchFilterResult
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface BatchMoveRequest
 */
export interface BatchMoveRequest {
    /**
     * 
     * @type {string}
     * @memberof BatchMoveRequest
     */
    'collectedAtMode'?: string;
    /**
     * 
     * @type {BatchFilterQuery}
     * @memberof BatchMoveRequest
     */
    'filterQuery'?: BatchFilterQuery;
    /**
     * 
     * @type {Array<number>}
     * @memberof BatchMoveRequest
     */
    'pageIds'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof BatchMoveRequest
     */
    'selectAll'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BatchMoveRequest
     */
    'targetCollectionId'?: number;
}
/**
 * 
 * @export
 * @interface BatchMoveResult
 */
export interface BatchMoveResult {
    /**
     * 
     * @type {number}
     * @memberof BatchMoveResult
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchMoveResult
     */
    'totalAffected'?: number;
}
/**
 * 
 * @export
 * @interface BatchPageItem
 */
export interface BatchPageItem {
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'collectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchPageItem
     */
    'contentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchPageItem
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'pageJsonProperties'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'publishTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchPageItem
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CapturePage
 */
export interface CapturePage {
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'baseUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'connectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CapturePage
     */
    'connectorId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof CapturePage
     */
    'contentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'faviconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'homeUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof CapturePage
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CapturePage
     */
    'isFavorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CapturePage
     */
    'isLiked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CapturePage
     */
    'needFindThumbUrl'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'pageJsonProperties'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'siteName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'subscribeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'thumbUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CapturePage
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CollectionGroup
 */
export interface CollectionGroup {
    /**
     * 
     * @type {string}
     * @memberof CollectionGroup
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroup
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionGroup
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroup
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroup
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CollectionGroupVO
 */
export interface CollectionGroupVO {
    /**
     * 
     * @type {Array<CollectionVO>}
     * @memberof CollectionGroupVO
     */
    'collections'?: Array<CollectionVO>;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroupVO
     */
    'color'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionGroupVO
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroupVO
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionGroupVO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionGroupVO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CollectionTreeVO
 */
export interface CollectionTreeVO {
    /**
     * 
     * @type {Array<CollectionGroupVO>}
     * @memberof CollectionTreeVO
     */
    'groups'?: Array<CollectionGroupVO>;
    /**
     * 
     * @type {number}
     * @memberof CollectionTreeVO
     */
    'unsortedCount'?: number;
}
/**
 * 
 * @export
 * @interface CollectionVO
 */
export interface CollectionVO {
    /**
     * 
     * @type {Array<CollectionVO>}
     * @memberof CollectionVO
     */
    'children'?: Array<CollectionVO>;
    /**
     * 
     * @type {string}
     * @memberof CollectionVO
     */
    'color'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionVO
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionVO
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionVO
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionVO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionVO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionVO
     */
    'pageCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionVO
     */
    'parentId'?: number;
}
/**
 * 
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'apiToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Connector
     */
    'crawlFullContent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Connector
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'fetchIntervalSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'fetchPageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'httpEtag'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'httpLastModified'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'iconUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'inboxCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'lastFetchBeginAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'lastFetchEndAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Connector
     */
    'lastFetchSuccess'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'subscribeUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Connector
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface ConnectorItem
 */
export interface ConnectorItem {
    /**
     * 
     * @type {string}
     * @memberof ConnectorItem
     */
    'iconUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorItem
     */
    'inboxCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorItem
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorItem
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface CreateHighlightRequest
 */
export interface CreateHighlightRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateHighlightRequest
     */
    'endOffset': number;
    /**
     * 
     * @type {string}
     * @memberof CreateHighlightRequest
     */
    'highlightedText': string;
    /**
     * 
     * @type {number}
     * @memberof CreateHighlightRequest
     */
    'pageId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateHighlightRequest
     */
    'startOffset': number;
}
/**
 * 
 * @export
 * @interface FeedsSetting
 */
export interface FeedsSetting {
    /**
     * 
     * @type {number}
     * @memberof FeedsSetting
     */
    'connectorId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FeedsSetting
     */
    'crawlFullContent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeedsSetting
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FeedsSetting
     */
    'fetchIntervalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedsSetting
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedsSetting
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedsSetting
     */
    'subscribeUrl'?: string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {Array<Connector>}
     * @memberof Folder
     */
    'connectors'?: Array<Connector>;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'displaySequence'?: number;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FolderConnectorView
 */
export interface FolderConnectorView {
    /**
     * 
     * @type {Array<FolderConnectors>}
     * @memberof FolderConnectorView
     */
    'folderFeedConnectors'?: Array<FolderConnectors>;
}
/**
 * 
 * @export
 * @interface FolderConnectors
 */
export interface FolderConnectors {
    /**
     * 
     * @type {Array<ConnectorItem>}
     * @memberof FolderConnectors
     */
    'connectorItems'?: Array<ConnectorItem>;
    /**
     * 
     * @type {number}
     * @memberof FolderConnectors
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FolderConnectors
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GitHubSetting
 */
export interface GitHubSetting {
    /**
     * 
     * @type {string}
     * @memberof GitHubSetting
     */
    'apiToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof GitHubSetting
     */
    'connectorId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GitHubSetting
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GitHubSetting
     */
    'fetchIntervalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof GitHubSetting
     */
    'fetchPageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof GitHubSetting
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitHubSetting
     */
    'tokenSet'?: boolean;
}
/**
 * 
 * @export
 * @interface GlobalSetting
 */
export interface GlobalSetting {
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'articleSummaryPrompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'autoSaveSiteBlacklists'?: string;
    /**
     * 
     * @type {number}
     * @memberof GlobalSetting
     */
    'autoSaveTweetMinLikes'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalSetting
     */
    'changedOpenApiKey'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GlobalSetting
     */
    'coldDataKeepDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'createdAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalSetting
     */
    'enableProxy'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GlobalSetting
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalSetting
     */
    'markReadOnScroll'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'mcpToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'openApiBaseUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'openApiKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'openApiModel'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'proxyHost'?: string;
    /**
     * 
     * @type {number}
     * @memberof GlobalSetting
     */
    'proxyPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof GlobalSetting
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface HighlightListItem
 */
export interface HighlightListItem {
    /**
     * 
     * @type {string}
     * @memberof HighlightListItem
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof HighlightListItem
     */
    'endOffset'?: number;
    /**
     * 
     * @type {string}
     * @memberof HighlightListItem
     */
    'highlightedText'?: string;
    /**
     * 
     * @type {number}
     * @memberof HighlightListItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof HighlightListItem
     */
    'pageId'?: number;
    /**
     * 
     * @type {string}
     * @memberof HighlightListItem
     */
    'pageTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof HighlightListItem
     */
    'pageUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof HighlightListItem
     */
    'startOffset'?: number;
}
/**
 * 
 * @export
 * @interface InterceptTweets
 */
export interface InterceptTweets {
    /**
     * 
     * @type {string}
     * @memberof InterceptTweets
     */
    'browserScreenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterceptTweets
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterceptTweets
     */
    'jsonData'?: string;
    /**
     * 
     * @type {string}
     * @memberof InterceptTweets
     */
    'loginScreenName'?: string;
    /**
     * 
     * @type {number}
     * @memberof InterceptTweets
     */
    'minLikes'?: number;
}
/**
 * 
 * @export
 * @interface LibraryExportInfo
 */
export interface LibraryExportInfo {
    /**
     * 
     * @type {string}
     * @memberof LibraryExportInfo
     */
    'completedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryExportInfo
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryExportInfo
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryExportInfo
     */
    'sizeBytes'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryExportInfo
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryExportInfo
     */
    'status'?: LibraryExportInfoStatusEnum;
}

export const LibraryExportInfoStatusEnum = {
    Empty: 'EMPTY',
    Failed: 'FAILED',
    InProgress: 'IN_PROGRESS',
    Missing: 'MISSING',
    Ready: 'READY'
} as const;

export type LibraryExportInfoStatusEnum = typeof LibraryExportInfoStatusEnum[keyof typeof LibraryExportInfoStatusEnum];

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface LoginUserInfo
 */
export interface LoginUserInfo {
    /**
     * 
     * @type {string}
     * @memberof LoginUserInfo
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'empty'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelAndView
     */
    'model'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModelAndView
     */
    'modelMap'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    'reference'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'status'?: ModelAndViewStatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    'view'?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    'viewName'?: string;
}

export const ModelAndViewStatusEnum = {
    Accepted: 'ACCEPTED',
    AlreadyReported: 'ALREADY_REPORTED',
    BadGateway: 'BAD_GATEWAY',
    BadRequest: 'BAD_REQUEST',
    BandwidthLimitExceeded: 'BANDWIDTH_LIMIT_EXCEEDED',
    Checkpoint: 'CHECKPOINT',
    Conflict: 'CONFLICT',
    Continue: 'CONTINUE',
    Created: 'CREATED',
    DestinationLocked: 'DESTINATION_LOCKED',
    ExpectationFailed: 'EXPECTATION_FAILED',
    FailedDependency: 'FAILED_DEPENDENCY',
    Forbidden: 'FORBIDDEN',
    Found: 'FOUND',
    GatewayTimeout: 'GATEWAY_TIMEOUT',
    Gone: 'GONE',
    HttpVersionNotSupported: 'HTTP_VERSION_NOT_SUPPORTED',
    ImUsed: 'IM_USED',
    InsufficientSpaceOnResource: 'INSUFFICIENT_SPACE_ON_RESOURCE',
    InsufficientStorage: 'INSUFFICIENT_STORAGE',
    InternalServerError: 'INTERNAL_SERVER_ERROR',
    IAmATeapot: 'I_AM_A_TEAPOT',
    LengthRequired: 'LENGTH_REQUIRED',
    Locked: 'LOCKED',
    LoopDetected: 'LOOP_DETECTED',
    MethodFailure: 'METHOD_FAILURE',
    MethodNotAllowed: 'METHOD_NOT_ALLOWED',
    MovedPermanently: 'MOVED_PERMANENTLY',
    MovedTemporarily: 'MOVED_TEMPORARILY',
    MultipleChoices: 'MULTIPLE_CHOICES',
    MultiStatus: 'MULTI_STATUS',
    NetworkAuthenticationRequired: 'NETWORK_AUTHENTICATION_REQUIRED',
    NonAuthoritativeInformation: 'NON_AUTHORITATIVE_INFORMATION',
    NotAcceptable: 'NOT_ACCEPTABLE',
    NotExtended: 'NOT_EXTENDED',
    NotFound: 'NOT_FOUND',
    NotImplemented: 'NOT_IMPLEMENTED',
    NotModified: 'NOT_MODIFIED',
    NoContent: 'NO_CONTENT',
    Ok: 'OK',
    PartialContent: 'PARTIAL_CONTENT',
    PayloadTooLarge: 'PAYLOAD_TOO_LARGE',
    PaymentRequired: 'PAYMENT_REQUIRED',
    PermanentRedirect: 'PERMANENT_REDIRECT',
    PreconditionFailed: 'PRECONDITION_FAILED',
    PreconditionRequired: 'PRECONDITION_REQUIRED',
    Processing: 'PROCESSING',
    ProxyAuthenticationRequired: 'PROXY_AUTHENTICATION_REQUIRED',
    RequestedRangeNotSatisfiable: 'REQUESTED_RANGE_NOT_SATISFIABLE',
    RequestEntityTooLarge: 'REQUEST_ENTITY_TOO_LARGE',
    RequestHeaderFieldsTooLarge: 'REQUEST_HEADER_FIELDS_TOO_LARGE',
    RequestTimeout: 'REQUEST_TIMEOUT',
    RequestUriTooLong: 'REQUEST_URI_TOO_LONG',
    ResetContent: 'RESET_CONTENT',
    SeeOther: 'SEE_OTHER',
    ServiceUnavailable: 'SERVICE_UNAVAILABLE',
    SwitchingProtocols: 'SWITCHING_PROTOCOLS',
    TemporaryRedirect: 'TEMPORARY_REDIRECT',
    TooEarly: 'TOO_EARLY',
    TooManyRequests: 'TOO_MANY_REQUESTS',
    Unauthorized: 'UNAUTHORIZED',
    UnavailableForLegalReasons: 'UNAVAILABLE_FOR_LEGAL_REASONS',
    UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
    UnsupportedMediaType: 'UNSUPPORTED_MEDIA_TYPE',
    UpgradeRequired: 'UPGRADE_REQUIRED',
    UriTooLong: 'URI_TOO_LONG',
    UseProxy: 'USE_PROXY',
    VariantAlsoNegotiates: 'VARIANT_ALSO_NEGOTIATES'
} as const;

export type ModelAndViewStatusEnum = typeof ModelAndViewStatusEnum[keyof typeof ModelAndViewStatusEnum];

/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'archivedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'authorScreenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'collectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'collectionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'connectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'connectorId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'connectorType'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'contentText'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'contentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'firstReadAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'folderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'highlightCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'lastReadAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'librarySaveStatus'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'markRead'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'pageJsonProperties'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'pageUniqueId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'readCostSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'readCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'readLater'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'readLaterAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'savedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'showOnPageList'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'sourceId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'starred'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'starredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'thumbUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'urlWithoutHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'voteScore'?: number;
}
/**
 * 
 * @export
 * @interface PageArticleContent
 */
export interface PageArticleContent {
    /**
     * 
     * @type {number}
     * @memberof PageArticleContent
     */
    'articleContentCategory'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageArticleContent
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageArticleContent
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageArticleContent
     */
    'pageId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageArticleContent
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PageDetail
 */
export interface PageDetail {
    /**
     * 
     * @type {ConnectorItem}
     * @memberof PageDetail
     */
    'connector'?: ConnectorItem;
    /**
     * 
     * @type {Page}
     * @memberof PageDetail
     */
    'page'?: Page;
    /**
     * 
     * @type {Array<PageArticleContent>}
     * @memberof PageDetail
     */
    'pageContents'?: Array<PageArticleContent>;
    /**
     * 
     * @type {Source}
     * @memberof PageDetail
     */
    'source'?: Source;
}
/**
 * 
 * @export
 * @interface PageHighlightDto
 */
export interface PageHighlightDto {
    /**
     * 
     * @type {string}
     * @memberof PageHighlightDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageHighlightDto
     */
    'endOffset'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageHighlightDto
     */
    'highlightedText'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageHighlightDto
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageHighlightDto
     */
    'pageId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageHighlightDto
     */
    'startOffset'?: number;
}
/**
 * 
 * @export
 * @interface PageItem
 */
export interface PageItem {
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'collectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'collectionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'connectedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'connectorId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'connectorType'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'contentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'faviconUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'folderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'highlightCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'language'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'librarySaveStatus'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageItem
     */
    'markRead'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'pageJsonProperties'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'pageUniqueId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'pubDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'readCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageItem
     */
    'readLater'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'recordAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'siteName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'sourceId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageItem
     */
    'starred'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'thumbUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageItem
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageItem
     */
    'voteScore'?: number;
}
/**
 * 
 * @export
 * @interface PageOfHighlightListItem
 */
export interface PageOfHighlightListItem {
    /**
     * 
     * @type {Array<HighlightListItem>}
     * @memberof PageOfHighlightListItem
     */
    'content'?: Array<HighlightListItem>;
    /**
     * 
     * @type {boolean}
     * @memberof PageOfHighlightListItem
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageOfHighlightListItem
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageOfHighlightListItem
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageOfHighlightListItem
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageOfHighlightListItem
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageOfHighlightListItem
     */
    'pageable'?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageOfHighlightListItem
     */
    'size'?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageOfHighlightListItem
     */
    'sort'?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageOfHighlightListItem
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageOfHighlightListItem
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface PageOperateResult
 */
export interface PageOperateResult {
    /**
     * 
     * @type {number}
     * @memberof PageOperateResult
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageOperateResult
     */
    'librarySaveStatus'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageOperateResult
     */
    'readLater'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageOperateResult
     */
    'starred'?: boolean;
}
/**
 * 
 * @export
 * @interface PageSearchResult
 */
export interface PageSearchResult {
    /**
     * 
     * @type {number}
     * @memberof PageSearchResult
     */
    'costSeconds'?: number;
    /**
     * 
     * @type {Array<PageItem>}
     * @memberof PageSearchResult
     */
    'items'?: Array<PageItem>;
    /**
     * 
     * @type {number}
     * @memberof PageSearchResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSearchResult
     */
    'totalHits'?: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    'paged'?: boolean;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    'sort'?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    'unpaged'?: boolean;
}
/**
 * 
 * @export
 * @interface PreviewFeedsInfo
 */
export interface PreviewFeedsInfo {
    /**
     * 
     * @type {string}
     * @memberof PreviewFeedsInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviewFeedsInfo
     */
    'feedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviewFeedsInfo
     */
    'siteFaviconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviewFeedsInfo
     */
    'siteLink'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PreviewFeedsInfo
     */
    'subscribed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PreviewFeedsInfo
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ProcessContentRequest
 */
export interface ProcessContentRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessContentRequest
     */
    'baseUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessContentRequest
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessContentRequest
     */
    'mode'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessContentRequest
     */
    'shortcutId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessContentRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof Resource
     */
    'file'?: File;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'filename'?: string;
    /**
     * 
     * @type {object}
     * @memberof Resource
     */
    'inputStream'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    'open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    'readable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SearchHistory
 */
export interface SearchHistory {
    /**
     * 
     * @type {number}
     * @memberof SearchHistory
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchHistory
     */
    'options'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistory
     */
    'query'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistory
     */
    'searchAt'?: string;
}
/**
 * 
 * @export
 * @interface SearchQuery
 */
export interface SearchQuery {
    /**
     * 
     * @type {number}
     * @memberof SearchQuery
     */
    'page'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchQuery
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchQuery
     */
    'queryOptions'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchQuery
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'faviconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'homeUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Source
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'siteName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'subscribeUrl'?: string;
}
/**
 * 
 * @export
 * @interface SseEmitter
 */
export interface SseEmitter {
    /**
     * 
     * @type {number}
     * @memberof SseEmitter
     */
    'timeout'?: number;
}
/**
 * 
 * @export
 * @interface TweetId
 */
export interface TweetId {
    /**
     * 
     * @type {string}
     * @memberof TweetId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TweetTrack
 */
export interface TweetTrack {
    /**
     * 
     * @type {number}
     * @memberof TweetTrack
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TweetTrack
     */
    'readAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TweetTrack
     */
    'setReadAt'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TweetTrack
     */
    'tweetId'?: string;
}
/**
 * 
 * @export
 * @interface TwitterUserSetting
 */
export interface TwitterUserSetting {
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'bookmarkToCollectionId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'bookmarkToLibraryType'?: number;
    /**
     * 
     * @type {string}
     * @memberof TwitterUserSetting
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'likeToCollectionId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'likeToLibraryType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TwitterUserSetting
     */
    'myself'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TwitterUserSetting
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitterUserSetting
     */
    'screenName'?: string;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'tweetToCollectionId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TwitterUserSetting
     */
    'tweetToLibraryType'?: number;
    /**
     * 
     * @type {string}
     * @memberof TwitterUserSetting
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'contentType'?: string;
}

/**
 * ArticleShortcutControllerApi - axios parameter creator
 * @export
 */
export const ArticleShortcutControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createShortcut
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShortcutUsingPOST: async (articleShortcut?: ArticleShortcut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleShortcut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteShortcut
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShortcutUsingDELETE: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteShortcutUsingDELETE', 'id', id)
            const localVarPath = `/api/article-shortcuts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShortcutsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEnabledShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledShortcutsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getImportableDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportableDefaultShortcutsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts/importable-defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getShortcutById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortcutByIdUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getShortcutByIdUsingGET', 'id', id)
            const localVarPath = `/api/article-shortcuts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary importDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDefaultShortcutsUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts/import-defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary importSelectedShortcuts
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSelectedShortcutsUsingPOST: async (requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts/import-selected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveShortcuts
         * @param {Array<ArticleShortcut>} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveShortcutsUsingPOST: async (articleShortcut?: Array<ArticleShortcut>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article-shortcuts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleShortcut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateShortcut
         * @param {number} id id
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShortcutUsingPUT: async (id: number, articleShortcut?: ArticleShortcut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShortcutUsingPUT', 'id', id)
            const localVarPath = `/api/article-shortcuts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleShortcut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticleShortcutControllerApi - functional programming interface
 * @export
 */
export const ArticleShortcutControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticleShortcutControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createShortcut
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShortcutUsingPOST(articleShortcut?: ArticleShortcut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShortcutUsingPOST(articleShortcut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteShortcut
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShortcutUsingDELETE(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShortcutUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllShortcutsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleShortcut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllShortcutsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getEnabledShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnabledShortcutsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleShortcut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnabledShortcutsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getImportableDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportableDefaultShortcutsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleShortcut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportableDefaultShortcutsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getShortcutById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShortcutByIdUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleShortcut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShortcutByIdUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary importDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importDefaultShortcutsUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleShortcut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importDefaultShortcutsUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary importSelectedShortcuts
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSelectedShortcutsUsingPOST(requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleShortcut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSelectedShortcutsUsingPOST(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveShortcuts
         * @param {Array<ArticleShortcut>} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveShortcutsUsingPOST(articleShortcut?: Array<ArticleShortcut>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveShortcutsUsingPOST(articleShortcut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateShortcut
         * @param {number} id id
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShortcutUsingPUT(id: number, articleShortcut?: ArticleShortcut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShortcutUsingPUT(id, articleShortcut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArticleShortcutControllerApi - factory interface
 * @export
 */
export const ArticleShortcutControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticleShortcutControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary createShortcut
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShortcutUsingPOST(articleShortcut?: ArticleShortcut, options?: any): AxiosPromise<object> {
            return localVarFp.createShortcutUsingPOST(articleShortcut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteShortcut
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShortcutUsingDELETE(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteShortcutUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShortcutsUsingGET(options?: any): AxiosPromise<Array<ArticleShortcut>> {
            return localVarFp.getAllShortcutsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getEnabledShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledShortcutsUsingGET(options?: any): AxiosPromise<Array<ArticleShortcut>> {
            return localVarFp.getEnabledShortcutsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getImportableDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportableDefaultShortcutsUsingGET(options?: any): AxiosPromise<Array<ArticleShortcut>> {
            return localVarFp.getImportableDefaultShortcutsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getShortcutById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortcutByIdUsingGET(id: number, options?: any): AxiosPromise<ArticleShortcut> {
            return localVarFp.getShortcutByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary importDefaultShortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDefaultShortcutsUsingPOST(options?: any): AxiosPromise<Array<ArticleShortcut>> {
            return localVarFp.importDefaultShortcutsUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary importSelectedShortcuts
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSelectedShortcutsUsingPOST(requestBody?: Array<string>, options?: any): AxiosPromise<Array<ArticleShortcut>> {
            return localVarFp.importSelectedShortcutsUsingPOST(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveShortcuts
         * @param {Array<ArticleShortcut>} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveShortcutsUsingPOST(articleShortcut?: Array<ArticleShortcut>, options?: any): AxiosPromise<object> {
            return localVarFp.saveShortcutsUsingPOST(articleShortcut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateShortcut
         * @param {number} id id
         * @param {ArticleShortcut} [articleShortcut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShortcutUsingPUT(id: number, articleShortcut?: ArticleShortcut, options?: any): AxiosPromise<object> {
            return localVarFp.updateShortcutUsingPUT(id, articleShortcut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticleShortcutControllerApi - object-oriented interface
 * @export
 * @class ArticleShortcutControllerApi
 * @extends {BaseAPI}
 */
export class ArticleShortcutControllerApi extends BaseAPI {
    /**
     * 
     * @summary createShortcut
     * @param {ArticleShortcut} [articleShortcut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public createShortcutUsingPOST(articleShortcut?: ArticleShortcut, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).createShortcutUsingPOST(articleShortcut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteShortcut
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public deleteShortcutUsingDELETE(id: number, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).deleteShortcutUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllShortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public getAllShortcutsUsingGET(options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).getAllShortcutsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getEnabledShortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public getEnabledShortcutsUsingGET(options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).getEnabledShortcutsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getImportableDefaultShortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public getImportableDefaultShortcutsUsingGET(options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).getImportableDefaultShortcutsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getShortcutById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public getShortcutByIdUsingGET(id: number, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).getShortcutByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary importDefaultShortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public importDefaultShortcutsUsingPOST(options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).importDefaultShortcutsUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary importSelectedShortcuts
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public importSelectedShortcutsUsingPOST(requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).importSelectedShortcutsUsingPOST(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveShortcuts
     * @param {Array<ArticleShortcut>} [articleShortcut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public saveShortcutsUsingPOST(articleShortcut?: Array<ArticleShortcut>, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).saveShortcutsUsingPOST(articleShortcut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateShortcut
     * @param {number} id id
     * @param {ArticleShortcut} [articleShortcut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleShortcutControllerApi
     */
    public updateShortcutUsingPUT(id: number, articleShortcut?: ArticleShortcut, options?: AxiosRequestConfig) {
        return ArticleShortcutControllerApiFp(this.configuration).updateShortcutUsingPUT(id, articleShortcut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isUserSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserSetUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/isUserSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary loginUserInfo
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUserInfoUsingGET: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/loginUserInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signin
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinUsingPOST: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signup
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUsingPOST: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary singOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singOutUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/signOut`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary isUserSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserSetUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isUserSetUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary loginUserInfo
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUserInfoUsingGET(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUserInfoUsingGET(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary signin
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signinUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfstring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signinUsingPOST(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary signup
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfstring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupUsingPOST(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary singOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async singOutUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfstring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.singOutUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary isUserSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserSetUsingGET(options?: any): AxiosPromise<ApiResultOfboolean> {
            return localVarFp.isUserSetUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary loginUserInfo
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUserInfoUsingGET(name?: string, options?: any): AxiosPromise<LoginUserInfo> {
            return localVarFp.loginUserInfoUsingGET(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signin
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinUsingPOST(loginRequest?: LoginRequest, options?: any): AxiosPromise<ApiResultOfstring> {
            return localVarFp.signinUsingPOST(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signup
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUsingPOST(loginRequest?: LoginRequest, options?: any): AxiosPromise<ApiResultOfstring> {
            return localVarFp.signupUsingPOST(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary singOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singOutUsingPOST(options?: any): AxiosPromise<ApiResultOfstring> {
            return localVarFp.singOutUsingPOST(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary isUserSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public isUserSetUsingGET(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).isUserSetUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary loginUserInfo
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public loginUserInfoUsingGET(name?: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).loginUserInfoUsingGET(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signin
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public signinUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).signinUsingPOST(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signup
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public signupUsingPOST(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).signupUsingPOST(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary singOut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public singOutUsingPOST(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).singOutUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingDELETE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingHEAD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingOPTIONS: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPATCH: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPUT: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingTRACE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'TRACE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicErrorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingDELETE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingHEAD(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingHEAD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingOPTIONS(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingOPTIONS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingPATCH(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPATCH(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingPUT(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingPUT(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorUsingTRACE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorUsingTRACE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicErrorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingDELETE(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingGET(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingHEAD(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingHEAD(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingOPTIONS(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingOPTIONS(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPATCH(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingPATCH(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPOST(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingPUT(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingPUT(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorUsingTRACE(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.errorUsingTRACE(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingDELETE(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingGET(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingHEAD(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingHEAD(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingOPTIONS(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingOPTIONS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingPATCH(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingPATCH(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingPOST(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingPUT(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorUsingTRACE(options?: AxiosRequestConfig) {
        return BasicErrorControllerApiFp(this.configuration).errorUsingTRACE(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BatchOrganizeControllerApi - axios parameter creator
 * @export
 */
export const BatchOrganizeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary batchMoveToCollection
         * @param {BatchMoveRequest} [batchMoveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchMoveToCollectionUsingPOST: async (batchMoveRequest?: BatchMoveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/batch/moveToCollection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary filterPages
         * @param {BatchFilterQuery} [batchFilterQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterPagesUsingPOST: async (batchFilterQuery?: BatchFilterQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/batch/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchFilterQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchOrganizeControllerApi - functional programming interface
 * @export
 */
export const BatchOrganizeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchOrganizeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary batchMoveToCollection
         * @param {BatchMoveRequest} [batchMoveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchMoveToCollectionUsingPOST(batchMoveRequest?: BatchMoveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfBatchMoveResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchMoveToCollectionUsingPOST(batchMoveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary filterPages
         * @param {BatchFilterQuery} [batchFilterQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterPagesUsingPOST(batchFilterQuery?: BatchFilterQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfBatchFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterPagesUsingPOST(batchFilterQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchOrganizeControllerApi - factory interface
 * @export
 */
export const BatchOrganizeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchOrganizeControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary batchMoveToCollection
         * @param {BatchMoveRequest} [batchMoveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchMoveToCollectionUsingPOST(batchMoveRequest?: BatchMoveRequest, options?: any): AxiosPromise<ApiResultOfBatchMoveResult> {
            return localVarFp.batchMoveToCollectionUsingPOST(batchMoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary filterPages
         * @param {BatchFilterQuery} [batchFilterQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterPagesUsingPOST(batchFilterQuery?: BatchFilterQuery, options?: any): AxiosPromise<ApiResultOfBatchFilterResult> {
            return localVarFp.filterPagesUsingPOST(batchFilterQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchOrganizeControllerApi - object-oriented interface
 * @export
 * @class BatchOrganizeControllerApi
 * @extends {BaseAPI}
 */
export class BatchOrganizeControllerApi extends BaseAPI {
    /**
     * 
     * @summary batchMoveToCollection
     * @param {BatchMoveRequest} [batchMoveRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchOrganizeControllerApi
     */
    public batchMoveToCollectionUsingPOST(batchMoveRequest?: BatchMoveRequest, options?: AxiosRequestConfig) {
        return BatchOrganizeControllerApiFp(this.configuration).batchMoveToCollectionUsingPOST(batchMoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary filterPages
     * @param {BatchFilterQuery} [batchFilterQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchOrganizeControllerApi
     */
    public filterPagesUsingPOST(batchFilterQuery?: BatchFilterQuery, options?: AxiosRequestConfig) {
        return BatchOrganizeControllerApiFp(this.configuration).filterPagesUsingPOST(batchFilterQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionControllerApi - axios parameter creator
 * @export
 */
export const CollectionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCollection
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollectionUsingPOST: async (collection?: Collection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createGroup
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupUsingPOST: async (collectionGroup?: CollectionGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collection-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCollection
         * @param {number} id id
         * @param {{ [key: string]: boolean; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionUsingDELETE: async (id: number, requestBody?: { [key: string]: boolean; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollectionUsingDELETE', 'id', id)
            const localVarPath = `/api/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteGroup
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupUsingDELETE: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroupUsingDELETE', 'id', id)
            const localVarPath = `/api/collection-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroupsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collection-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCollection
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollectionUsingGET', 'id', id)
            const localVarPath = `/api/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPageCount
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageCountUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPageCountUsingGET', 'id', id)
            const localVarPath = `/api/collections/{id}/page-count`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreeUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collections/tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reorderCollections
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderCollectionsUsingPOST: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collections/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reorderGroups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderGroupsUsingPOST: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/collection-groups/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCollection
         * @param {number} id id
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionUsingPUT: async (id: number, collection?: Collection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCollectionUsingPUT', 'id', id)
            const localVarPath = `/api/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateGroup
         * @param {number} id id
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupUsingPUT: async (id: number, collectionGroup?: CollectionGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroupUsingPUT', 'id', id)
            const localVarPath = `/api/collection-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionControllerApi - functional programming interface
 * @export
 */
export const CollectionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createCollection
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollectionUsingPOST(collection?: Collection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollectionUsingPOST(collection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createGroup
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupUsingPOST(collectionGroup?: CollectionGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupUsingPOST(collectionGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteCollection
         * @param {number} id id
         * @param {{ [key: string]: boolean; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionUsingDELETE(id: number, requestBody?: { [key: string]: boolean; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionUsingDELETE(id, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteGroup
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupUsingDELETE(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGroupsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollectionGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGroupsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getCollection
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPageCount
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageCountUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageCountUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTreeUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionTreeVO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTreeUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary reorderCollections
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderCollectionsUsingPOST(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderCollectionsUsingPOST(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary reorderGroups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderGroupsUsingPOST(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderGroupsUsingPOST(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateCollection
         * @param {number} id id
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollectionUsingPUT(id: number, collection?: Collection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollectionUsingPUT(id, collection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateGroup
         * @param {number} id id
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupUsingPUT(id: number, collectionGroup?: CollectionGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupUsingPUT(id, collectionGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionControllerApi - factory interface
 * @export
 */
export const CollectionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary createCollection
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollectionUsingPOST(collection?: Collection, options?: any): AxiosPromise<Collection> {
            return localVarFp.createCollectionUsingPOST(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createGroup
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupUsingPOST(collectionGroup?: CollectionGroup, options?: any): AxiosPromise<CollectionGroup> {
            return localVarFp.createGroupUsingPOST(collectionGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteCollection
         * @param {number} id id
         * @param {{ [key: string]: boolean; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionUsingDELETE(id: number, requestBody?: { [key: string]: boolean; }, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionUsingDELETE(id, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteGroup
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupUsingDELETE(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroupsUsingGET(options?: any): AxiosPromise<Array<CollectionGroup>> {
            return localVarFp.getAllGroupsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCollection
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionUsingGET(id: number, options?: any): AxiosPromise<Collection> {
            return localVarFp.getCollectionUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPageCount
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageCountUsingGET(id: number, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getPageCountUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreeUsingGET(options?: any): AxiosPromise<CollectionTreeVO> {
            return localVarFp.getTreeUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reorderCollections
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderCollectionsUsingPOST(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.reorderCollectionsUsingPOST(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reorderGroups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderGroupsUsingPOST(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.reorderGroupsUsingPOST(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCollection
         * @param {number} id id
         * @param {Collection} [collection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionUsingPUT(id: number, collection?: Collection, options?: any): AxiosPromise<Collection> {
            return localVarFp.updateCollectionUsingPUT(id, collection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateGroup
         * @param {number} id id
         * @param {CollectionGroup} [collectionGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupUsingPUT(id: number, collectionGroup?: CollectionGroup, options?: any): AxiosPromise<CollectionGroup> {
            return localVarFp.updateGroupUsingPUT(id, collectionGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionControllerApi - object-oriented interface
 * @export
 * @class CollectionControllerApi
 * @extends {BaseAPI}
 */
export class CollectionControllerApi extends BaseAPI {
    /**
     * 
     * @summary createCollection
     * @param {Collection} [collection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public createCollectionUsingPOST(collection?: Collection, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).createCollectionUsingPOST(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createGroup
     * @param {CollectionGroup} [collectionGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public createGroupUsingPOST(collectionGroup?: CollectionGroup, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).createGroupUsingPOST(collectionGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteCollection
     * @param {number} id id
     * @param {{ [key: string]: boolean; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public deleteCollectionUsingDELETE(id: number, requestBody?: { [key: string]: boolean; }, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).deleteCollectionUsingDELETE(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteGroup
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public deleteGroupUsingDELETE(id: number, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).deleteGroupUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public getAllGroupsUsingGET(options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).getAllGroupsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCollection
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public getCollectionUsingGET(id: number, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).getCollectionUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPageCount
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public getPageCountUsingGET(id: number, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).getPageCountUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTree
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public getTreeUsingGET(options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).getTreeUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reorderCollections
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public reorderCollectionsUsingPOST(body?: object, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).reorderCollectionsUsingPOST(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reorderGroups
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public reorderGroupsUsingPOST(body?: object, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).reorderGroupsUsingPOST(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCollection
     * @param {number} id id
     * @param {Collection} [collection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public updateCollectionUsingPUT(id: number, collection?: Collection, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).updateCollectionUsingPUT(id, collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateGroup
     * @param {number} id id
     * @param {CollectionGroup} [collectionGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionControllerApi
     */
    public updateGroupUsingPUT(id: number, collectionGroup?: CollectionGroup, options?: AxiosRequestConfig) {
        return CollectionControllerApiFp(this.configuration).updateGroupUsingPUT(id, collectionGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorControllerApi - axios parameter creator
 * @export
 */
export const ConnectorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getConnectorById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorByIdUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorByIdUsingGET', 'id', id)
            const localVarPath = `/api/connector/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFolderConnectorView
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderConnectorViewUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector/folder-connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGitHubConnector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubConnectorUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGitHubInboxCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubInboxCountUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector/github/inboxCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUnreadFeedCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadFeedCountUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector/feeds/unreadCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorControllerApi - functional programming interface
 * @export
 */
export const ConnectorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getConnectorById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorByIdUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorByIdUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getFolderConnectorView
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderConnectorViewUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderConnectorView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderConnectorViewUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGitHubConnector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitHubConnectorUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitHubConnectorUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGitHubInboxCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitHubInboxCountUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOflong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitHubInboxCountUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getUnreadFeedCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnreadFeedCountUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOflong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnreadFeedCountUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorControllerApi - factory interface
 * @export
 */
export const ConnectorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getConnectorById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorByIdUsingGET(id: number, options?: any): AxiosPromise<Connector> {
            return localVarFp.getConnectorByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFolderConnectorView
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderConnectorViewUsingGET(options?: any): AxiosPromise<FolderConnectorView> {
            return localVarFp.getFolderConnectorViewUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGitHubConnector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubConnectorUsingGET(options?: any): AxiosPromise<ConnectorItem> {
            return localVarFp.getGitHubConnectorUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGitHubInboxCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubInboxCountUsingGET(options?: any): AxiosPromise<ApiResultOflong> {
            return localVarFp.getGitHubInboxCountUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUnreadFeedCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadFeedCountUsingGET(options?: any): AxiosPromise<ApiResultOflong> {
            return localVarFp.getUnreadFeedCountUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorControllerApi - object-oriented interface
 * @export
 * @class ConnectorControllerApi
 * @extends {BaseAPI}
 */
export class ConnectorControllerApi extends BaseAPI {
    /**
     * 
     * @summary getConnectorById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorControllerApi
     */
    public getConnectorByIdUsingGET(id: number, options?: AxiosRequestConfig) {
        return ConnectorControllerApiFp(this.configuration).getConnectorByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFolderConnectorView
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorControllerApi
     */
    public getFolderConnectorViewUsingGET(options?: AxiosRequestConfig) {
        return ConnectorControllerApiFp(this.configuration).getFolderConnectorViewUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGitHubConnector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorControllerApi
     */
    public getGitHubConnectorUsingGET(options?: AxiosRequestConfig) {
        return ConnectorControllerApiFp(this.configuration).getGitHubConnectorUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGitHubInboxCount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorControllerApi
     */
    public getGitHubInboxCountUsingGET(options?: AxiosRequestConfig) {
        return ConnectorControllerApiFp(this.configuration).getGitHubInboxCountUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUnreadFeedCount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorControllerApi
     */
    public getUnreadFeedCountUsingGET(options?: AxiosRequestConfig) {
        return ConnectorControllerApiFp(this.configuration).getUnreadFeedCountUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FolderControllerApi - axios parameter creator
 * @export
 */
export const FolderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getFolderById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByIdUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFolderByIdUsingGET', 'id', id)
            const localVarPath = `/api/folder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderControllerApi - functional programming interface
 * @export
 */
export const FolderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getFolderById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderByIdUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderByIdUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FolderControllerApi - factory interface
 * @export
 */
export const FolderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getFolderById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByIdUsingGET(id: number, options?: any): AxiosPromise<Folder> {
            return localVarFp.getFolderByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderControllerApi - object-oriented interface
 * @export
 * @class FolderControllerApi
 * @extends {BaseAPI}
 */
export class FolderControllerApi extends BaseAPI {
    /**
     * 
     * @summary getFolderById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderControllerApi
     */
    public getFolderByIdUsingGET(id: number, options?: AxiosRequestConfig) {
        return FolderControllerApiFp(this.configuration).getFolderByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthControllerApi - axios parameter creator
 * @export
 */
export const HealthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthControllerApi - functional programming interface
 * @export
 */
export const HealthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthControllerApi - factory interface
 * @export
 */
export const HealthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.healthUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthControllerApi - object-oriented interface
 * @export
 * @class HealthControllerApi
 * @extends {BaseAPI}
 */
export class HealthControllerApi extends BaseAPI {
    /**
     * 
     * @summary health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthControllerApi
     */
    public healthUsingGET(options?: AxiosRequestConfig) {
        return HealthControllerApiFp(this.configuration).healthUsingGET(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryExportControllerApi - axios parameter creator
 * @export
 */
export const LibraryExportControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary downloadExport
         * @param {string} fileName fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExportUsingGET: async (fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadExportUsingGET', 'fileName', fileName)
            const localVarPath = `/api/library-export/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getExportStatus
         * @param {string} [fileName] fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportStatusUsingGET: async (fileName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/library-export/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLatestExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExportUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/library-export/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary startExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExportUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/library-export/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryExportControllerApi - functional programming interface
 * @export
 */
export const LibraryExportControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryExportControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary downloadExport
         * @param {string} fileName fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExportUsingGET(fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExportUsingGET(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getExportStatus
         * @param {string} [fileName] fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportStatusUsingGET(fileName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfLibraryExportInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportStatusUsingGET(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getLatestExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestExportUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfLibraryExportInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestExportUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary startExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startExportUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfLibraryExportInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startExportUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LibraryExportControllerApi - factory interface
 * @export
 */
export const LibraryExportControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryExportControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary downloadExport
         * @param {string} fileName fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExportUsingGET(fileName: string, options?: any): AxiosPromise<Resource> {
            return localVarFp.downloadExportUsingGET(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getExportStatus
         * @param {string} [fileName] fileName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportStatusUsingGET(fileName?: string, options?: any): AxiosPromise<ApiResultOfLibraryExportInfo> {
            return localVarFp.getExportStatusUsingGET(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getLatestExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExportUsingGET(options?: any): AxiosPromise<ApiResultOfLibraryExportInfo> {
            return localVarFp.getLatestExportUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary startExport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExportUsingPOST(options?: any): AxiosPromise<ApiResultOfLibraryExportInfo> {
            return localVarFp.startExportUsingPOST(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryExportControllerApi - object-oriented interface
 * @export
 * @class LibraryExportControllerApi
 * @extends {BaseAPI}
 */
export class LibraryExportControllerApi extends BaseAPI {
    /**
     * 
     * @summary downloadExport
     * @param {string} fileName fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryExportControllerApi
     */
    public downloadExportUsingGET(fileName: string, options?: AxiosRequestConfig) {
        return LibraryExportControllerApiFp(this.configuration).downloadExportUsingGET(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getExportStatus
     * @param {string} [fileName] fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryExportControllerApi
     */
    public getExportStatusUsingGET(fileName?: string, options?: AxiosRequestConfig) {
        return LibraryExportControllerApiFp(this.configuration).getExportStatusUsingGET(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getLatestExport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryExportControllerApi
     */
    public getLatestExportUsingGET(options?: AxiosRequestConfig) {
        return LibraryExportControllerApiFp(this.configuration).getLatestExportUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary startExport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryExportControllerApi
     */
    public startExportUsingPOST(options?: AxiosRequestConfig) {
        return LibraryExportControllerApiFp(this.configuration).startExportUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * McpServerControllerApi - axios parameter creator
 * @export
 */
export const McpServerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary connect
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectUsingGET: async (authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mcp/sse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mcp/tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleMessage
         * @param {string} [authorization] Authorization
         * @param {string} [sessionId] sessionId
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMessageUsingPOST: async (authorization?: string, sessionId?: string, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mcp/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary testTool
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testToolUsingPOST: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mcp/tools/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * McpServerControllerApi - functional programming interface
 * @export
 */
export const McpServerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = McpServerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary connect
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectUsingGET(authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SseEmitter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectUsingGET(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: object; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary handleMessage
         * @param {string} [authorization] Authorization
         * @param {string} [sessionId] sessionId
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleMessageUsingPOST(authorization?: string, sessionId?: string, body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleMessageUsingPOST(authorization, sessionId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary testTool
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testToolUsingPOST(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testToolUsingPOST(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * McpServerControllerApi - factory interface
 * @export
 */
export const McpServerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = McpServerControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary connect
         * @param {string} [authorization] Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectUsingGET(authorization?: string, options?: any): AxiosPromise<SseEmitter> {
            return localVarFp.connectUsingGET(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsUsingGET(options?: any): AxiosPromise<Array<{ [key: string]: object; }>> {
            return localVarFp.getToolsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary handleMessage
         * @param {string} [authorization] Authorization
         * @param {string} [sessionId] sessionId
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMessageUsingPOST(authorization?: string, sessionId?: string, body?: object, options?: any): AxiosPromise<string> {
            return localVarFp.handleMessageUsingPOST(authorization, sessionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary testTool
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testToolUsingPOST(body?: object, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.testToolUsingPOST(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * McpServerControllerApi - object-oriented interface
 * @export
 * @class McpServerControllerApi
 * @extends {BaseAPI}
 */
export class McpServerControllerApi extends BaseAPI {
    /**
     * 
     * @summary connect
     * @param {string} [authorization] Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof McpServerControllerApi
     */
    public connectUsingGET(authorization?: string, options?: AxiosRequestConfig) {
        return McpServerControllerApiFp(this.configuration).connectUsingGET(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof McpServerControllerApi
     */
    public getToolsUsingGET(options?: AxiosRequestConfig) {
        return McpServerControllerApiFp(this.configuration).getToolsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary handleMessage
     * @param {string} [authorization] Authorization
     * @param {string} [sessionId] sessionId
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof McpServerControllerApi
     */
    public handleMessageUsingPOST(authorization?: string, sessionId?: string, body?: object, options?: AxiosRequestConfig) {
        return McpServerControllerApiFp(this.configuration).handleMessageUsingPOST(authorization, sessionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary testTool
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof McpServerControllerApi
     */
    public testToolUsingPOST(body?: object, options?: AxiosRequestConfig) {
        return McpServerControllerApiFp(this.configuration).testToolUsingPOST(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageControllerApi - axios parameter creator
 * @export
 */
export const PageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary archiveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveToLibraryUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveToLibraryUsingPOST', 'id', id)
            const localVarPath = `/api/page/archive/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageUsingDELETE: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePageUsingDELETE', 'id', id)
            const localVarPath = `/api/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary fetchFullContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFullContentByIdUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fetchFullContentByIdUsingPOST', 'id', id)
            const localVarPath = `/api/page/fullContent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPageDetailById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDetailByIdUsingGET: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPageDetailByIdUsingGET', 'id', id)
            const localVarPath = `/api/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPageOperateResult
         * @param {number} [id] 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageOperateResultUsingGET: async (id?: number, url?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/pageOperateResult`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getReadLaterCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadLaterCountUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/readLaterCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listPageItems
         * @param {boolean} [asc] 
         * @param {number} [collectionId] 
         * @param {number} [connectorId] 
         * @param {number} [connectorType] 
         * @param {number} [contentFilterType] 
         * @param {'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET'} [contentType] 
         * @param {number} [count] 
         * @param {string} [endDate] 
         * @param {boolean} [filterUnsorted] 
         * @param {string} [firstRecordAt] 
         * @param {number} [firstVoteScore] 
         * @param {number} [folderId] 
         * @param {boolean} [hasHighlights] 
         * @param {boolean} [includeArchived] 
         * @param {string} [lastRecordAt] 
         * @param {number} [lastVoteScore] 
         * @param {boolean} [markRead] 
         * @param {boolean} [readLater] 
         * @param {'ARCHIVED' | 'NOT_SAVED' | 'SAVED'} [saveStatus] 
         * @param {'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE'} [sort] 
         * @param {number} [sourceId] 
         * @param {boolean} [starred] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPageItemsUsingGET: async (asc?: boolean, collectionId?: number, connectorId?: number, connectorType?: number, contentFilterType?: number, contentType?: 'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET', count?: number, endDate?: string, filterUnsorted?: boolean, firstRecordAt?: string, firstVoteScore?: number, folderId?: number, hasHighlights?: boolean, includeArchived?: boolean, lastRecordAt?: string, lastVoteScore?: number, markRead?: boolean, readLater?: boolean, saveStatus?: 'ARCHIVED' | 'NOT_SAVED' | 'SAVED', sort?: 'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE', sourceId?: number, starred?: boolean, startDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (collectionId !== undefined) {
                localVarQueryParameter['collectionId'] = collectionId;
            }

            if (connectorId !== undefined) {
                localVarQueryParameter['connectorId'] = connectorId;
            }

            if (connectorType !== undefined) {
                localVarQueryParameter['connectorType'] = connectorType;
            }

            if (contentFilterType !== undefined) {
                localVarQueryParameter['contentFilterType'] = contentFilterType;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (filterUnsorted !== undefined) {
                localVarQueryParameter['filterUnsorted'] = filterUnsorted;
            }

            if (firstRecordAt !== undefined) {
                localVarQueryParameter['firstRecordAt'] = (firstRecordAt as any instanceof Date) ?
                    (firstRecordAt as any).toISOString() :
                    firstRecordAt;
            }

            if (firstVoteScore !== undefined) {
                localVarQueryParameter['firstVoteScore'] = firstVoteScore;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (hasHighlights !== undefined) {
                localVarQueryParameter['hasHighlights'] = hasHighlights;
            }

            if (includeArchived !== undefined) {
                localVarQueryParameter['includeArchived'] = includeArchived;
            }

            if (lastRecordAt !== undefined) {
                localVarQueryParameter['lastRecordAt'] = (lastRecordAt as any instanceof Date) ?
                    (lastRecordAt as any).toISOString() :
                    lastRecordAt;
            }

            if (lastVoteScore !== undefined) {
                localVarQueryParameter['lastVoteScore'] = lastVoteScore;
            }

            if (markRead !== undefined) {
                localVarQueryParameter['markRead'] = markRead;
            }

            if (readLater !== undefined) {
                localVarQueryParameter['readLater'] = readLater;
            }

            if (saveStatus !== undefined) {
                localVarQueryParameter['saveStatus'] = saveStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (starred !== undefined) {
                localVarQueryParameter['starred'] = starred;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markReadByConnectorId
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByConnectorIdUsingPOST: async (connectorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('markReadByConnectorIdUsingPOST', 'connectorId', connectorId)
            const localVarPath = `/api/page/markReadByConnectorId/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markReadByConnectorType
         * @param {number} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByConnectorTypeUsingPOST: async (type: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('markReadByConnectorTypeUsingPOST', 'type', type)
            const localVarPath = `/api/page/markReadByConnectorType/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markReadByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByFolderIdUsingPOST: async (folderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('markReadByFolderIdUsingPOST', 'folderId', folderId)
            const localVarPath = `/api/page/markReadByFolderId/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markReadByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByPageIdsUsingPOST: async (requestBody?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/markReadByPageIds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary markReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('markReadPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/markRead/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processContentWithShortcut
         * @param {ProcessContentRequest} [processContentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentWithShortcutUsingPOST: async (processContentRequest?: ProcessContentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/processContentWithShortcut`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processContentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processWithShortcut
         * @param {number} id id
         * @param {number} shortcutId shortcutId
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWithShortcutUsingGET: async (id: number, shortcutId: number, mode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('processWithShortcutUsingGET', 'id', id)
            // verify required parameter 'shortcutId' is not null or undefined
            assertParamExists('processWithShortcutUsingGET', 'shortcutId', shortcutId)
            const localVarPath = `/api/page/processWithShortcut/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shortcutId !== undefined) {
                localVarQueryParameter['shortcutId'] = shortcutId;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary readLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLaterPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readLaterPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/readLater/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary recordReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordReadPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recordReadPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/recordReadPage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removeFromLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromLibraryUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeFromLibraryUsingPOST', 'id', id)
            const localVarPath = `/api/page/removeFromLibrary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary savePage
         * @param {CapturePage} [capturePage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePageUsingPOST: async (capturePage?: CapturePage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(capturePage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveToLibraryUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveToLibraryUsingPOST', 'id', id)
            const localVarPath = `/api/page/saveToLibrary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary starPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('starPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/star/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary switchRawContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchRawContentByIdUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('switchRawContentByIdUsingPOST', 'id', id)
            const localVarPath = `/api/page/rawContent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unMarkReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unMarkReadPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unMarkReadPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/unMarkRead/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unReadLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unReadLaterPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unReadLaterPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/unReadLater/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unStarPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unStarPageUsingPOST: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unStarPageUsingPOST', 'id', id)
            const localVarPath = `/api/page/unStar/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePageCollection
         * @param {number} id id
         * @param {{ [key: string]: number; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageCollectionUsingPATCH: async (id: number, requestBody?: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePageCollectionUsingPATCH', 'id', id)
            const localVarPath = `/api/page/{id}/collection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageControllerApi - functional programming interface
 * @export
 */
export const PageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary archiveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveToLibraryUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveToLibraryUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePageUsingDELETE(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePageUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary fetchFullContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchFullContentByIdUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFullContentByIdUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPageDetailById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageDetailByIdUsingGET(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageDetailByIdUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPageOperateResult
         * @param {number} [id] 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageOperateResultUsingGET(id?: number, url?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOperateResultUsingGET(id, url, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getReadLaterCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReadLaterCountUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOflong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReadLaterCountUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary listPageItems
         * @param {boolean} [asc] 
         * @param {number} [collectionId] 
         * @param {number} [connectorId] 
         * @param {number} [connectorType] 
         * @param {number} [contentFilterType] 
         * @param {'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET'} [contentType] 
         * @param {number} [count] 
         * @param {string} [endDate] 
         * @param {boolean} [filterUnsorted] 
         * @param {string} [firstRecordAt] 
         * @param {number} [firstVoteScore] 
         * @param {number} [folderId] 
         * @param {boolean} [hasHighlights] 
         * @param {boolean} [includeArchived] 
         * @param {string} [lastRecordAt] 
         * @param {number} [lastVoteScore] 
         * @param {boolean} [markRead] 
         * @param {boolean} [readLater] 
         * @param {'ARCHIVED' | 'NOT_SAVED' | 'SAVED'} [saveStatus] 
         * @param {'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE'} [sort] 
         * @param {number} [sourceId] 
         * @param {boolean} [starred] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPageItemsUsingGET(asc?: boolean, collectionId?: number, connectorId?: number, connectorType?: number, contentFilterType?: number, contentType?: 'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET', count?: number, endDate?: string, filterUnsorted?: boolean, firstRecordAt?: string, firstVoteScore?: number, folderId?: number, hasHighlights?: boolean, includeArchived?: boolean, lastRecordAt?: string, lastVoteScore?: number, markRead?: boolean, readLater?: boolean, saveStatus?: 'ARCHIVED' | 'NOT_SAVED' | 'SAVED', sort?: 'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE', sourceId?: number, starred?: boolean, startDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PageItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPageItemsUsingGET(asc, collectionId, connectorId, connectorType, contentFilterType, contentType, count, endDate, filterUnsorted, firstRecordAt, firstVoteScore, folderId, hasHighlights, includeArchived, lastRecordAt, lastVoteScore, markRead, readLater, saveStatus, sort, sourceId, starred, startDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary markReadByConnectorId
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markReadByConnectorIdUsingPOST(connectorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markReadByConnectorIdUsingPOST(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary markReadByConnectorType
         * @param {number} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markReadByConnectorTypeUsingPOST(type: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markReadByConnectorTypeUsingPOST(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary markReadByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markReadByFolderIdUsingPOST(folderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markReadByFolderIdUsingPOST(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary markReadByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markReadByPageIdsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markReadByPageIdsUsingPOST(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary markReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markReadPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markReadPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary processContentWithShortcut
         * @param {ProcessContentRequest} [processContentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processContentWithShortcutUsingPOST(processContentRequest?: ProcessContentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SseEmitter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processContentWithShortcutUsingPOST(processContentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary processWithShortcut
         * @param {number} id id
         * @param {number} shortcutId shortcutId
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processWithShortcutUsingGET(id: number, shortcutId: number, mode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SseEmitter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processWithShortcutUsingGET(id, shortcutId, mode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary readLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readLaterPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readLaterPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary recordReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordReadPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordReadPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary removeFromLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromLibraryUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromLibraryUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary savePage
         * @param {CapturePage} [capturePage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savePageUsingPOST(capturePage?: CapturePage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOflong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savePageUsingPOST(capturePage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveToLibraryUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveToLibraryUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary starPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary switchRawContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchRawContentByIdUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchRawContentByIdUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unMarkReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unMarkReadPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unMarkReadPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unReadLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unReadLaterPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unReadLaterPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unStarPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unStarPageUsingPOST(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOperateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unStarPageUsingPOST(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePageCollection
         * @param {number} id id
         * @param {{ [key: string]: number; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageCollectionUsingPATCH(id: number, requestBody?: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePageCollectionUsingPATCH(id, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageControllerApi - factory interface
 * @export
 */
export const PageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary archiveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveToLibraryUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.archiveToLibraryUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageUsingDELETE(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePageUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary fetchFullContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFullContentByIdUsingPOST(id: number, options?: any): AxiosPromise<ArticleContent> {
            return localVarFp.fetchFullContentByIdUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPageDetailById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDetailByIdUsingGET(id: number, options?: any): AxiosPromise<PageDetail> {
            return localVarFp.getPageDetailByIdUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPageOperateResult
         * @param {number} [id] 
         * @param {string} [url] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageOperateResultUsingGET(id?: number, url?: string, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.getPageOperateResultUsingGET(id, url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getReadLaterCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadLaterCountUsingGET(options?: any): AxiosPromise<ApiResultOflong> {
            return localVarFp.getReadLaterCountUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary listPageItems
         * @param {boolean} [asc] 
         * @param {number} [collectionId] 
         * @param {number} [connectorId] 
         * @param {number} [connectorType] 
         * @param {number} [contentFilterType] 
         * @param {'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET'} [contentType] 
         * @param {number} [count] 
         * @param {string} [endDate] 
         * @param {boolean} [filterUnsorted] 
         * @param {string} [firstRecordAt] 
         * @param {number} [firstVoteScore] 
         * @param {number} [folderId] 
         * @param {boolean} [hasHighlights] 
         * @param {boolean} [includeArchived] 
         * @param {string} [lastRecordAt] 
         * @param {number} [lastVoteScore] 
         * @param {boolean} [markRead] 
         * @param {boolean} [readLater] 
         * @param {'ARCHIVED' | 'NOT_SAVED' | 'SAVED'} [saveStatus] 
         * @param {'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE'} [sort] 
         * @param {number} [sourceId] 
         * @param {boolean} [starred] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPageItemsUsingGET(asc?: boolean, collectionId?: number, connectorId?: number, connectorType?: number, contentFilterType?: number, contentType?: 'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET', count?: number, endDate?: string, filterUnsorted?: boolean, firstRecordAt?: string, firstVoteScore?: number, folderId?: number, hasHighlights?: boolean, includeArchived?: boolean, lastRecordAt?: string, lastVoteScore?: number, markRead?: boolean, readLater?: boolean, saveStatus?: 'ARCHIVED' | 'NOT_SAVED' | 'SAVED', sort?: 'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE', sourceId?: number, starred?: boolean, startDate?: string, options?: any): AxiosPromise<Array<PageItem>> {
            return localVarFp.listPageItemsUsingGET(asc, collectionId, connectorId, connectorType, contentFilterType, contentType, count, endDate, filterUnsorted, firstRecordAt, firstVoteScore, folderId, hasHighlights, includeArchived, lastRecordAt, lastVoteScore, markRead, readLater, saveStatus, sort, sourceId, starred, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary markReadByConnectorId
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByConnectorIdUsingPOST(connectorId: number, options?: any): AxiosPromise<ApiResultOfint> {
            return localVarFp.markReadByConnectorIdUsingPOST(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary markReadByConnectorType
         * @param {number} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByConnectorTypeUsingPOST(type: number, options?: any): AxiosPromise<ApiResultOfint> {
            return localVarFp.markReadByConnectorTypeUsingPOST(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary markReadByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByFolderIdUsingPOST(folderId: number, options?: any): AxiosPromise<ApiResultOfint> {
            return localVarFp.markReadByFolderIdUsingPOST(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary markReadByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadByPageIdsUsingPOST(requestBody?: Array<number>, options?: any): AxiosPromise<ApiResultOfint> {
            return localVarFp.markReadByPageIdsUsingPOST(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary markReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markReadPageUsingPOST(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.markReadPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary processContentWithShortcut
         * @param {ProcessContentRequest} [processContentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentWithShortcutUsingPOST(processContentRequest?: ProcessContentRequest, options?: any): AxiosPromise<SseEmitter> {
            return localVarFp.processContentWithShortcutUsingPOST(processContentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary processWithShortcut
         * @param {number} id id
         * @param {number} shortcutId shortcutId
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWithShortcutUsingGET(id: number, shortcutId: number, mode?: string, options?: any): AxiosPromise<SseEmitter> {
            return localVarFp.processWithShortcutUsingGET(id, shortcutId, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary readLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLaterPageUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.readLaterPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary recordReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordReadPageUsingPOST(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.recordReadPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary removeFromLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromLibraryUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.removeFromLibraryUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary savePage
         * @param {CapturePage} [capturePage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePageUsingPOST(capturePage?: CapturePage, options?: any): AxiosPromise<ApiResultOflong> {
            return localVarFp.savePageUsingPOST(capturePage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveToLibrary
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveToLibraryUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.saveToLibraryUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary starPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starPageUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.starPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary switchRawContentById
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchRawContentByIdUsingPOST(id: number, options?: any): AxiosPromise<ArticleContent> {
            return localVarFp.switchRawContentByIdUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unMarkReadPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unMarkReadPageUsingPOST(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.unMarkReadPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unReadLaterPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unReadLaterPageUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.unReadLaterPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unStarPage
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unStarPageUsingPOST(id: number, options?: any): AxiosPromise<PageOperateResult> {
            return localVarFp.unStarPageUsingPOST(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePageCollection
         * @param {number} id id
         * @param {{ [key: string]: number; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageCollectionUsingPATCH(id: number, requestBody?: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.updatePageCollectionUsingPATCH(id, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageControllerApi - object-oriented interface
 * @export
 * @class PageControllerApi
 * @extends {BaseAPI}
 */
export class PageControllerApi extends BaseAPI {
    /**
     * 
     * @summary archiveToLibrary
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public archiveToLibraryUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).archiveToLibraryUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public deletePageUsingDELETE(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).deletePageUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary fetchFullContentById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public fetchFullContentByIdUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).fetchFullContentByIdUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPageDetailById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getPageDetailByIdUsingGET(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getPageDetailByIdUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPageOperateResult
     * @param {number} [id] 
     * @param {string} [url] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getPageOperateResultUsingGET(id?: number, url?: string, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getPageOperateResultUsingGET(id, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getReadLaterCount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getReadLaterCountUsingGET(options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getReadLaterCountUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary listPageItems
     * @param {boolean} [asc] 
     * @param {number} [collectionId] 
     * @param {number} [connectorId] 
     * @param {number} [connectorType] 
     * @param {number} [contentFilterType] 
     * @param {'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET'} [contentType] 
     * @param {number} [count] 
     * @param {string} [endDate] 
     * @param {boolean} [filterUnsorted] 
     * @param {string} [firstRecordAt] 
     * @param {number} [firstVoteScore] 
     * @param {number} [folderId] 
     * @param {boolean} [hasHighlights] 
     * @param {boolean} [includeArchived] 
     * @param {string} [lastRecordAt] 
     * @param {number} [lastVoteScore] 
     * @param {boolean} [markRead] 
     * @param {boolean} [readLater] 
     * @param {'ARCHIVED' | 'NOT_SAVED' | 'SAVED'} [saveStatus] 
     * @param {'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE'} [sort] 
     * @param {number} [sourceId] 
     * @param {boolean} [starred] 
     * @param {string} [startDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public listPageItemsUsingGET(asc?: boolean, collectionId?: number, connectorId?: number, connectorType?: number, contentFilterType?: number, contentType?: 'BROWSER_HISTORY' | 'MARKDOWN' | 'QUOTED_TWEET' | 'SNIPPET' | 'TWEET', count?: number, endDate?: string, filterUnsorted?: boolean, firstRecordAt?: string, firstVoteScore?: number, folderId?: number, hasHighlights?: boolean, includeArchived?: boolean, lastRecordAt?: string, lastVoteScore?: number, markRead?: boolean, readLater?: boolean, saveStatus?: 'ARCHIVED' | 'NOT_SAVED' | 'SAVED', sort?: 'ARCHIVED_AT' | 'COLLECTED_AT' | 'CONNECTED_AT' | 'CREATED_AT' | 'LAST_READ_AT' | 'READ_LATER_AT' | 'SAVED_AT' | 'STARRED_AT' | 'UNSORTED_SAVED_AT' | 'VOTE_SCORE', sourceId?: number, starred?: boolean, startDate?: string, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).listPageItemsUsingGET(asc, collectionId, connectorId, connectorType, contentFilterType, contentType, count, endDate, filterUnsorted, firstRecordAt, firstVoteScore, folderId, hasHighlights, includeArchived, lastRecordAt, lastVoteScore, markRead, readLater, saveStatus, sort, sourceId, starred, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary markReadByConnectorId
     * @param {number} connectorId connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public markReadByConnectorIdUsingPOST(connectorId: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).markReadByConnectorIdUsingPOST(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary markReadByConnectorType
     * @param {number} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public markReadByConnectorTypeUsingPOST(type: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).markReadByConnectorTypeUsingPOST(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary markReadByFolderId
     * @param {number} folderId folderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public markReadByFolderIdUsingPOST(folderId: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).markReadByFolderIdUsingPOST(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary markReadByPageIds
     * @param {Array<number>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public markReadByPageIdsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).markReadByPageIdsUsingPOST(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary markReadPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public markReadPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).markReadPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary processContentWithShortcut
     * @param {ProcessContentRequest} [processContentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public processContentWithShortcutUsingPOST(processContentRequest?: ProcessContentRequest, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).processContentWithShortcutUsingPOST(processContentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary processWithShortcut
     * @param {number} id id
     * @param {number} shortcutId shortcutId
     * @param {string} [mode] mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public processWithShortcutUsingGET(id: number, shortcutId: number, mode?: string, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).processWithShortcutUsingGET(id, shortcutId, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary readLaterPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public readLaterPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).readLaterPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary recordReadPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public recordReadPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).recordReadPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary removeFromLibrary
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public removeFromLibraryUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).removeFromLibraryUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary savePage
     * @param {CapturePage} [capturePage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public savePageUsingPOST(capturePage?: CapturePage, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).savePageUsingPOST(capturePage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveToLibrary
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public saveToLibraryUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).saveToLibraryUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary starPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public starPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).starPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary switchRawContentById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public switchRawContentByIdUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).switchRawContentByIdUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unMarkReadPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public unMarkReadPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).unMarkReadPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unReadLaterPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public unReadLaterPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).unReadLaterPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unStarPage
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public unStarPageUsingPOST(id: number, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).unStarPageUsingPOST(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePageCollection
     * @param {number} id id
     * @param {{ [key: string]: number; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public updatePageCollectionUsingPATCH(id: number, requestBody?: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).updatePageCollectionUsingPATCH(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageHighlightControllerApi - axios parameter creator
 * @export
 */
export const PageHighlightControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createHighlight
         * @param {CreateHighlightRequest} [createHighlightRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST: async (createHighlightRequest?: CreateHighlightRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page-highlight`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHighlightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteHighlight
         * @param {number} highlightId highlightId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightUsingDELETE: async (highlightId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'highlightId' is not null or undefined
            assertParamExists('deleteHighlightUsingDELETE', 'highlightId', highlightId)
            const localVarPath = `/api/page-highlight/{highlightId}`
                .replace(`{${"highlightId"}}`, encodeURIComponent(String(highlightId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightsByPageIdUsingDELETE: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('deleteHighlightsByPageIdUsingDELETE', 'pageId', pageId)
            const localVarPath = `/api/page-highlight/page/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {string} [direction] 
         * @param {string} [endDate] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingGET: async (direction?: string, endDate?: string, page?: number, size?: number, sort?: string, startDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page-highlight/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsByPageIdUsingGET: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getHighlightsByPageIdUsingGET', 'pageId', pageId)
            const localVarPath = `/api/page-highlight/page/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightsByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsByPageIdsUsingPOST: async (requestBody?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/page-highlight/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageHighlightControllerApi - functional programming interface
 * @export
 */
export const PageHighlightControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageHighlightControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createHighlight
         * @param {CreateHighlightRequest} [createHighlightRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHighlightUsingPOST(createHighlightRequest?: CreateHighlightRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfPageHighlightDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHighlightUsingPOST(createHighlightRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteHighlight
         * @param {number} highlightId highlightId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHighlightUsingDELETE(highlightId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHighlightUsingDELETE(highlightId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHighlightsByPageIdUsingDELETE(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHighlightsByPageIdUsingDELETE(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getHighlightList
         * @param {string} [direction] 
         * @param {string} [endDate] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightListUsingGET(direction?: string, endDate?: string, page?: number, size?: number, sort?: string, startDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfPageOfHighlightListItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightListUsingGET(direction, endDate, page, size, sort, startDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightsByPageIdUsingGET(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfListOfPageHighlightDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightsByPageIdUsingGET(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getHighlightsByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightsByPageIdsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfMapOflongAndListOfPageHighlightDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighlightsByPageIdsUsingPOST(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageHighlightControllerApi - factory interface
 * @export
 */
export const PageHighlightControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageHighlightControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary createHighlight
         * @param {CreateHighlightRequest} [createHighlightRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST(createHighlightRequest?: CreateHighlightRequest, options?: any): AxiosPromise<ApiResultOfPageHighlightDto> {
            return localVarFp.createHighlightUsingPOST(createHighlightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteHighlight
         * @param {number} highlightId highlightId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightUsingDELETE(highlightId: number, options?: any): AxiosPromise<ApiResultOfboolean> {
            return localVarFp.deleteHighlightUsingDELETE(highlightId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightsByPageIdUsingDELETE(pageId: number, options?: any): AxiosPromise<ApiResultOfboolean> {
            return localVarFp.deleteHighlightsByPageIdUsingDELETE(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getHighlightList
         * @param {string} [direction] 
         * @param {string} [endDate] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingGET(direction?: string, endDate?: string, page?: number, size?: number, sort?: string, startDate?: string, options?: any): AxiosPromise<ApiResultOfPageOfHighlightListItem> {
            return localVarFp.getHighlightListUsingGET(direction, endDate, page, size, sort, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getHighlightsByPageId
         * @param {number} pageId pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsByPageIdUsingGET(pageId: number, options?: any): AxiosPromise<ApiResultOfListOfPageHighlightDto> {
            return localVarFp.getHighlightsByPageIdUsingGET(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getHighlightsByPageIds
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightsByPageIdsUsingPOST(requestBody?: Array<number>, options?: any): AxiosPromise<ApiResultOfMapOflongAndListOfPageHighlightDto> {
            return localVarFp.getHighlightsByPageIdsUsingPOST(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageHighlightControllerApi - object-oriented interface
 * @export
 * @class PageHighlightControllerApi
 * @extends {BaseAPI}
 */
export class PageHighlightControllerApi extends BaseAPI {
    /**
     * 
     * @summary createHighlight
     * @param {CreateHighlightRequest} [createHighlightRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public createHighlightUsingPOST(createHighlightRequest?: CreateHighlightRequest, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).createHighlightUsingPOST(createHighlightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteHighlight
     * @param {number} highlightId highlightId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public deleteHighlightUsingDELETE(highlightId: number, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).deleteHighlightUsingDELETE(highlightId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteHighlightsByPageId
     * @param {number} pageId pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public deleteHighlightsByPageIdUsingDELETE(pageId: number, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).deleteHighlightsByPageIdUsingDELETE(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getHighlightList
     * @param {string} [direction] 
     * @param {string} [endDate] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sort] 
     * @param {string} [startDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public getHighlightListUsingGET(direction?: string, endDate?: string, page?: number, size?: number, sort?: string, startDate?: string, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).getHighlightListUsingGET(direction, endDate, page, size, sort, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getHighlightsByPageId
     * @param {number} pageId pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public getHighlightsByPageIdUsingGET(pageId: number, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).getHighlightsByPageIdUsingGET(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getHighlightsByPageIds
     * @param {Array<number>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageHighlightControllerApi
     */
    public getHighlightsByPageIdsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig) {
        return PageHighlightControllerApiFp(this.configuration).getHighlightsByPageIdsUsingPOST(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchControllerApi - axios parameter creator
 * @export
 */
export const SearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRecentSearches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearchesUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searchPages
         * @param {SearchQuery} [searchQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPagesUsingPOST: async (searchQuery?: SearchQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchControllerApi - functional programming interface
 * @export
 */
export const SearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getRecentSearches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentSearchesUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentSearchesUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary searchPages
         * @param {SearchQuery} [searchQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPagesUsingPOST(searchQuery?: SearchQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPagesUsingPOST(searchQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchControllerApi - factory interface
 * @export
 */
export const SearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getRecentSearches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearchesUsingGET(options?: any): AxiosPromise<Array<SearchHistory>> {
            return localVarFp.getRecentSearchesUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searchPages
         * @param {SearchQuery} [searchQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPagesUsingPOST(searchQuery?: SearchQuery, options?: any): AxiosPromise<PageSearchResult> {
            return localVarFp.searchPagesUsingPOST(searchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchControllerApi - object-oriented interface
 * @export
 * @class SearchControllerApi
 * @extends {BaseAPI}
 */
export class SearchControllerApi extends BaseAPI {
    /**
     * 
     * @summary getRecentSearches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public getRecentSearchesUsingGET(options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).getRecentSearchesUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searchPages
     * @param {SearchQuery} [searchQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public searchPagesUsingPOST(searchQuery?: SearchQuery, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).searchPagesUsingPOST(searchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingControllerApi - axios parameter creator
 * @export
 */
export const SettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteFeed
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedUsingPOST: async (connectorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('deleteFeedUsingPOST', 'connectorId', connectorId)
            const localVarPath = `/api/setting/feeds/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (connectorId !== undefined) {
                localVarQueryParameter['connectorId'] = connectorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteFolder
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderUsingPOST: async (folderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolderUsingPOST', 'folderId', folderId)
            const localVarPath = `/api/setting/folder/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exportOpml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportOpmlUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/feeds/export-opml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary followFeed
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followFeedUsingPOST: async (subscribeUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeUrl' is not null or undefined
            assertParamExists('followFeedUsingPOST', 'subscribeUrl', subscribeUrl)
            const localVarPath = `/api/setting/feeds/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subscribeUrl !== undefined) {
                localVarQueryParameter['subscribeUrl'] = subscribeUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generateMcpToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMcpTokenUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/general/generateMcpToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/general/blacklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFeedsSetting
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedsSettingUsingGET: async (connectorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getFeedsSettingUsingGET', 'connectorId', connectorId)
            const localVarPath = `/api/setting/feeds/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (connectorId !== undefined) {
                localVarQueryParameter['connectorId'] = connectorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGitHubSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubSettingUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/github/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGlobalSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettingUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/general/globalSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSortedConnectorsByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedConnectorsByFolderIdUsingGET: async (folderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getSortedConnectorsByFolderIdUsingGET', 'folderId', folderId)
            const localVarPath = `/api/setting/folder/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSortedFolders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedFoldersUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/folder/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTwitterUserSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwitterUserSettingsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/twitter/UserSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary importOpml
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOpmlUsingPOST: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importOpmlUsingPOST', 'file', file)
            const localVarPath = `/api/setting/feeds/import-opml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isGithubPersonalTokenSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isGithubPersonalTokenSetUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/github/is-token-set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary previewFeeds
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewFeedsUsingGET: async (subscribeUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeUrl' is not null or undefined
            assertParamExists('previewFeedsUsingGET', 'subscribeUrl', subscribeUrl)
            const localVarPath = `/api/setting/feeds/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subscribeUrl !== undefined) {
                localVarQueryParameter['subscribeUrl'] = subscribeUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resortConnectors
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resortConnectorsUsingPOST: async (requestBody?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/feeds/resort`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resortFolders
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resortFoldersUsingPOST: async (requestBody?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/folder/resort`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveFolder
         * @param {Folder} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFolderUsingPOST: async (folder?: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/folder/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveGitHubSetting
         * @param {GitHubSetting} [gitHubSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGitHubSettingUsingPOST: async (gitHubSetting?: GitHubSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/github/saveSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitHubSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveGithubPersonalToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGithubPersonalTokenUsingPOST: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('saveGithubPersonalTokenUsingPOST', 'token', token)
            const localVarPath = `/api/setting/github/save-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveGlobalSetting
         * @param {GlobalSetting} [globalSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGlobalSettingUsingPOST: async (globalSetting?: GlobalSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/general/saveGlobalSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(globalSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveTwitterUserSettings
         * @param {Array<TwitterUserSetting>} [twitterUserSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTwitterUserSettingsUsingPOST: async (twitterUserSetting?: Array<TwitterUserSetting>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/twitter/saveUserSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twitterUserSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateFeedsSetting
         * @param {FeedsSetting} [feedsSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedsSettingUsingPOST: async (feedsSetting?: FeedsSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/feeds/updateSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedsSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateLoginUser
         * @param {string} [name] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginUserUsingPOST: async (name?: string, loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/setting/user/updateLoginUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingControllerApi - functional programming interface
 * @export
 */
export const SettingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteFeed
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedUsingPOST(connectorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeedUsingPOST(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteFolder
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolderUsingPOST(folderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolderUsingPOST(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary exportOpml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportOpmlUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportOpmlUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary followFeed
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followFeedUsingPOST(subscribeUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followFeedUsingPOST(subscribeUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary generateMcpToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMcpTokenUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfstring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMcpTokenUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlacklistUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlacklistUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getFeedsSetting
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedsSettingUsingGET(connectorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedsSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedsSettingUsingGET(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGitHubSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitHubSettingUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHubSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitHubSettingUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGlobalSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalSettingUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalSettingUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getSortedConnectorsByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSortedConnectorsByFolderIdUsingGET(folderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSortedConnectorsByFolderIdUsingGET(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getSortedFolders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSortedFoldersUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Folder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSortedFoldersUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTwitterUserSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwitterUserSettingsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TwitterUserSetting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwitterUserSettingsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary importOpml
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importOpmlUsingPOST(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importOpmlUsingPOST(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary isGithubPersonalTokenSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isGithubPersonalTokenSetUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfboolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isGithubPersonalTokenSetUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary previewFeeds
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewFeedsUsingGET(subscribeUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewFeedsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewFeedsUsingGET(subscribeUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary resortConnectors
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resortConnectorsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resortConnectorsUsingPOST(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary resortFolders
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resortFoldersUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resortFoldersUsingPOST(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveFolder
         * @param {Folder} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFolderUsingPOST(folder?: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFolderUsingPOST(folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveGitHubSetting
         * @param {GitHubSetting} [gitHubSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGitHubSettingUsingPOST(gitHubSetting?: GitHubSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGitHubSettingUsingPOST(gitHubSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveGithubPersonalToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGithubPersonalTokenUsingPOST(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGithubPersonalTokenUsingPOST(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveGlobalSetting
         * @param {GlobalSetting} [globalSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGlobalSettingUsingPOST(globalSetting?: GlobalSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGlobalSettingUsingPOST(globalSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveTwitterUserSettings
         * @param {Array<TwitterUserSetting>} [twitterUserSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTwitterUserSettingsUsingPOST(twitterUserSetting?: Array<TwitterUserSetting>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTwitterUserSettingsUsingPOST(twitterUserSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateFeedsSetting
         * @param {FeedsSetting} [feedsSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedsSettingUsingPOST(feedsSetting?: FeedsSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedsSettingUsingPOST(feedsSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateLoginUser
         * @param {string} [name] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginUserUsingPOST(name?: string, loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoginUserUsingPOST(name, loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingControllerApi - factory interface
 * @export
 */
export const SettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteFeed
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedUsingPOST(connectorId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFeedUsingPOST(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteFolder
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolderUsingPOST(folderId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFolderUsingPOST(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary exportOpml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportOpmlUsingPOST(options?: any): AxiosPromise<Resource> {
            return localVarFp.exportOpmlUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary followFeed
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followFeedUsingPOST(subscribeUrl: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.followFeedUsingPOST(subscribeUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary generateMcpToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMcpTokenUsingPOST(options?: any): AxiosPromise<ApiResultOfstring> {
            return localVarFp.generateMcpTokenUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistUsingGET(options?: any): AxiosPromise<string> {
            return localVarFp.getBlacklistUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFeedsSetting
         * @param {number} connectorId connectorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedsSettingUsingGET(connectorId: number, options?: any): AxiosPromise<FeedsSetting> {
            return localVarFp.getFeedsSettingUsingGET(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGitHubSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitHubSettingUsingGET(options?: any): AxiosPromise<GitHubSetting> {
            return localVarFp.getGitHubSettingUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGlobalSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettingUsingGET(options?: any): AxiosPromise<GlobalSetting> {
            return localVarFp.getGlobalSettingUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getSortedConnectorsByFolderId
         * @param {number} folderId folderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedConnectorsByFolderIdUsingGET(folderId: number, options?: any): AxiosPromise<Array<Connector>> {
            return localVarFp.getSortedConnectorsByFolderIdUsingGET(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getSortedFolders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedFoldersUsingGET(options?: any): AxiosPromise<Array<Folder>> {
            return localVarFp.getSortedFoldersUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTwitterUserSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwitterUserSettingsUsingGET(options?: any): AxiosPromise<Array<TwitterUserSetting>> {
            return localVarFp.getTwitterUserSettingsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary importOpml
         * @param {File} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOpmlUsingPOST(file: File, options?: any): AxiosPromise<void> {
            return localVarFp.importOpmlUsingPOST(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary isGithubPersonalTokenSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isGithubPersonalTokenSetUsingGET(options?: any): AxiosPromise<ApiResultOfboolean> {
            return localVarFp.isGithubPersonalTokenSetUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary previewFeeds
         * @param {string} subscribeUrl subscribeUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewFeedsUsingGET(subscribeUrl: string, options?: any): AxiosPromise<PreviewFeedsInfo> {
            return localVarFp.previewFeedsUsingGET(subscribeUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resortConnectors
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resortConnectorsUsingPOST(requestBody?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.resortConnectorsUsingPOST(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resortFolders
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resortFoldersUsingPOST(requestBody?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.resortFoldersUsingPOST(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveFolder
         * @param {Folder} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFolderUsingPOST(folder?: Folder, options?: any): AxiosPromise<Folder> {
            return localVarFp.saveFolderUsingPOST(folder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveGitHubSetting
         * @param {GitHubSetting} [gitHubSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGitHubSettingUsingPOST(gitHubSetting?: GitHubSetting, options?: any): AxiosPromise<Connector> {
            return localVarFp.saveGitHubSettingUsingPOST(gitHubSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveGithubPersonalToken
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGithubPersonalTokenUsingPOST(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.saveGithubPersonalTokenUsingPOST(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveGlobalSetting
         * @param {GlobalSetting} [globalSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGlobalSettingUsingPOST(globalSetting?: GlobalSetting, options?: any): AxiosPromise<GlobalSetting> {
            return localVarFp.saveGlobalSettingUsingPOST(globalSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveTwitterUserSettings
         * @param {Array<TwitterUserSetting>} [twitterUserSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTwitterUserSettingsUsingPOST(twitterUserSetting?: Array<TwitterUserSetting>, options?: any): AxiosPromise<void> {
            return localVarFp.saveTwitterUserSettingsUsingPOST(twitterUserSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateFeedsSetting
         * @param {FeedsSetting} [feedsSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedsSettingUsingPOST(feedsSetting?: FeedsSetting, options?: any): AxiosPromise<Connector> {
            return localVarFp.updateFeedsSettingUsingPOST(feedsSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateLoginUser
         * @param {string} [name] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginUserUsingPOST(name?: string, loginRequest?: LoginRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLoginUserUsingPOST(name, loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingControllerApi - object-oriented interface
 * @export
 * @class SettingControllerApi
 * @extends {BaseAPI}
 */
export class SettingControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteFeed
     * @param {number} connectorId connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public deleteFeedUsingPOST(connectorId: number, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).deleteFeedUsingPOST(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteFolder
     * @param {number} folderId folderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public deleteFolderUsingPOST(folderId: number, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).deleteFolderUsingPOST(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary exportOpml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public exportOpmlUsingPOST(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).exportOpmlUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary followFeed
     * @param {string} subscribeUrl subscribeUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public followFeedUsingPOST(subscribeUrl: string, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).followFeedUsingPOST(subscribeUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary generateMcpToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public generateMcpTokenUsingPOST(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).generateMcpTokenUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getBlacklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getBlacklistUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getBlacklistUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFeedsSetting
     * @param {number} connectorId connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getFeedsSettingUsingGET(connectorId: number, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getFeedsSettingUsingGET(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGitHubSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getGitHubSettingUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getGitHubSettingUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGlobalSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getGlobalSettingUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getGlobalSettingUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getSortedConnectorsByFolderId
     * @param {number} folderId folderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getSortedConnectorsByFolderIdUsingGET(folderId: number, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getSortedConnectorsByFolderIdUsingGET(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getSortedFolders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getSortedFoldersUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getSortedFoldersUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTwitterUserSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public getTwitterUserSettingsUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).getTwitterUserSettingsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary importOpml
     * @param {File} file file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public importOpmlUsingPOST(file: File, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).importOpmlUsingPOST(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary isGithubPersonalTokenSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public isGithubPersonalTokenSetUsingGET(options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).isGithubPersonalTokenSetUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary previewFeeds
     * @param {string} subscribeUrl subscribeUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public previewFeedsUsingGET(subscribeUrl: string, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).previewFeedsUsingGET(subscribeUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resortConnectors
     * @param {Array<number>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public resortConnectorsUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).resortConnectorsUsingPOST(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resortFolders
     * @param {Array<number>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public resortFoldersUsingPOST(requestBody?: Array<number>, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).resortFoldersUsingPOST(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveFolder
     * @param {Folder} [folder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public saveFolderUsingPOST(folder?: Folder, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).saveFolderUsingPOST(folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveGitHubSetting
     * @param {GitHubSetting} [gitHubSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public saveGitHubSettingUsingPOST(gitHubSetting?: GitHubSetting, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).saveGitHubSettingUsingPOST(gitHubSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveGithubPersonalToken
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public saveGithubPersonalTokenUsingPOST(token: string, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).saveGithubPersonalTokenUsingPOST(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveGlobalSetting
     * @param {GlobalSetting} [globalSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public saveGlobalSettingUsingPOST(globalSetting?: GlobalSetting, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).saveGlobalSettingUsingPOST(globalSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveTwitterUserSettings
     * @param {Array<TwitterUserSetting>} [twitterUserSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public saveTwitterUserSettingsUsingPOST(twitterUserSetting?: Array<TwitterUserSetting>, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).saveTwitterUserSettingsUsingPOST(twitterUserSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateFeedsSetting
     * @param {FeedsSetting} [feedsSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public updateFeedsSettingUsingPOST(feedsSetting?: FeedsSetting, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).updateFeedsSettingUsingPOST(feedsSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateLoginUser
     * @param {string} [name] 
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public updateLoginUserUsingPOST(name?: string, loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return SettingControllerApiFp(this.configuration).updateLoginUserUsingPOST(name, loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TweetControllerApi - axios parameter creator
 * @export
 */
export const TweetControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary saveTweets
         * @param {InterceptTweets} [interceptTweets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTweetsUsingPOST: async (interceptTweets?: InterceptTweets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tweet/saveTweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interceptTweets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary trackRead
         * @param {TweetId} [tweetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackReadUsingPOST: async (tweetId?: TweetId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tweet/trackRead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tweetId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweetControllerApi - functional programming interface
 * @export
 */
export const TweetControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TweetControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary saveTweets
         * @param {InterceptTweets} [interceptTweets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTweetsUsingPOST(interceptTweets?: InterceptTweets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResultOfint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTweetsUsingPOST(interceptTweets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary trackRead
         * @param {TweetId} [tweetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackReadUsingPOST(tweetId?: TweetId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetTrack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackReadUsingPOST(tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TweetControllerApi - factory interface
 * @export
 */
export const TweetControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweetControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary saveTweets
         * @param {InterceptTweets} [interceptTweets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTweetsUsingPOST(interceptTweets?: InterceptTweets, options?: any): AxiosPromise<ApiResultOfint> {
            return localVarFp.saveTweetsUsingPOST(interceptTweets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary trackRead
         * @param {TweetId} [tweetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackReadUsingPOST(tweetId?: TweetId, options?: any): AxiosPromise<TweetTrack> {
            return localVarFp.trackReadUsingPOST(tweetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TweetControllerApi - object-oriented interface
 * @export
 * @class TweetControllerApi
 * @extends {BaseAPI}
 */
export class TweetControllerApi extends BaseAPI {
    /**
     * 
     * @summary saveTweets
     * @param {InterceptTweets} [interceptTweets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetControllerApi
     */
    public saveTweetsUsingPOST(interceptTweets?: InterceptTweets, options?: AxiosRequestConfig) {
        return TweetControllerApiFp(this.configuration).saveTweetsUsingPOST(interceptTweets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary trackRead
     * @param {TweetId} [tweetId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetControllerApi
     */
    public trackReadUsingPOST(tweetId?: TweetId, options?: AxiosRequestConfig) {
        return TweetControllerApiFp(this.configuration).trackReadUsingPOST(tweetId, options).then((request) => request(this.axios, this.basePath));
    }
}


